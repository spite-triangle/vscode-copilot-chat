"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerNewWorkspaceIntentCommand = registerNewWorkspaceIntentCommand;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_1 = require("vscode");
const path = __importStar(require("../../../util/vs/base/common/path"));
const newIntent_1 = require("../../intents/node/newIntent");
const newWorkspacePreviewFileSystemProvider_1 = require("../../intents/vscode-node/newWorkspacePreviewFileSystemProvider");
const newWorkspaceTextDocumentProvider_1 = require("../../intents/vscode-node/newWorkspaceTextDocumentProvider");
const fileTreeParser_1 = require("../../prompt/common/fileTreeParser");
function registerNewWorkspaceIntentCommand(previewContentManager, logService, options) {
    return vscode_1.Disposable.from(vscode_1.workspace.registerFileSystemProvider(newIntent_1.CopilotWorkspaceScheme, new newWorkspacePreviewFileSystemProvider_1.NewWorkspacePreviewFileSystemProvider(previewContentManager), { isReadonly: new vscode_1.MarkdownString(vscode_1.l10n.t('This file preview was generated by Copilot and may contain surprises or mistakes.\n\nAsk followup questions to refine it, then press Create Workspace.')) }), vscode_1.workspace.registerFileSystemProvider(newIntent_1.GithubWorkspaceScheme, new newWorkspacePreviewFileSystemProvider_1.NewWorkspacePreviewFileSystemProvider(previewContentManager), { isReadonly: true }), vscode_1.workspace.registerTextDocumentContentProvider(newIntent_1.CopilotFileScheme, new newWorkspaceTextDocumentProvider_1.NewWorkspaceTextDocumentProvider(previewContentManager)), vscode_1.commands.registerCommand(newIntent_1.CreateProjectCommand, async (fileTreePart, workspaceRoot) => {
        const parentFolder = (await vscode_1.window.showOpenDialog({ defaultUri: workspaceRoot, title: path.basename(fileTreePart.baseUri.path), canSelectFolders: true, canSelectFiles: false, canSelectMany: false, openLabel: 'Select as Parent Folder' }))?.[0];
        if (!parentFolder) {
            return;
        }
        await createWorkspace(logService, workspaceRoot, parentFolder, fileTreePart);
    }), vscode_1.commands.registerCommand(newIntent_1.OpenFileCommand, async (fileTreePart) => {
        const pathStr = vscode_1.Uri.joinPath(fileTreePart.baseUri, fileTreePart.value[0].name).toString();
        const document = await vscode_1.workspace.openTextDocument(vscode_1.Uri.parse(pathStr));
        await vscode_1.window.showTextDocument(document, { preview: false });
    }), vscode_1.commands.registerCommand(newIntent_1.CreateFileCommand, async (fileTreePart) => {
        const options = {
            defaultUri: vscode_1.Uri.file(path.posix.join(vscode_1.workspace.workspaceFolders?.[0].uri.path ?? '', fileTreePart.value[0].name)),
            saveLabel: vscode_1.l10n.t('Save File'),
        };
        const uri = await vscode_1.window.showSaveDialog(options);
        if (uri) {
            const pathStr = vscode_1.Uri.joinPath(fileTreePart.baseUri, fileTreePart.value[0].name).toString();
            const document = await vscode_1.workspace.openTextDocument(vscode_1.Uri.parse(pathStr));
            await vscode_1.workspace.fs.writeFile(uri, Buffer.from(document.getText()));
            // Close out all previews since they won't properly restore
            const tabsToClose = [];
            vscode_1.window.tabGroups.all.forEach(group => {
                group.tabs.forEach((tab) => {
                    if (tab.input instanceof vscode_1.TabInputText && tab.input.uri.scheme === newIntent_1.CopilotFileScheme) {
                        tabsToClose.push(tab);
                    }
                });
            });
            vscode_1.window.tabGroups.close(tabsToClose, true);
            // re-open saved file
            const fileDoc = await vscode_1.workspace.openTextDocument(vscode_1.Uri.file(uri.fsPath));
            await vscode_1.window.showTextDocument(fileDoc);
        }
    }));
}
async function createWorkspace(logService, workspaceRoot, parentFolder, fileTreePart) {
    // Close out all previews since they won't properly restore
    const tabsToClose = [];
    vscode_1.window.tabGroups.all.forEach(group => {
        group.tabs.forEach((tab) => {
            if (tab.input instanceof vscode_1.TabInputText && tab.input.uri.scheme === newIntent_1.CopilotWorkspaceScheme) {
                tabsToClose.push(tab);
            }
        });
    });
    vscode_1.window.tabGroups.close(tabsToClose, true);
    // remove path separator from the beginning of the path
    const projectRoot = fileTreePart.baseUri.path.slice(1);
    const projectName = await getUniqueProjectName(parentFolder, projectRoot);
    const workspaceUri = vscode_1.Uri.joinPath(parentFolder, projectName);
    const files = (0, fileTreeParser_1.listFilesInResponseFileTree)(fileTreePart.value);
    if (files.length === 0) {
        return;
    }
    try {
        await vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Notification, cancellable: true }, async (progress, token) => {
            for (const file of files) {
                const relativeFilePath = path.relative(projectRoot, file);
                const fileUri = vscode_1.Uri.joinPath(workspaceUri, relativeFilePath);
                progress.report({ message: vscode_1.l10n.t(`Creating file {0}...`, fileUri.fsPath) });
                const content = await vscode_1.workspace.fs.readFile(vscode_1.Uri.joinPath(fileTreePart.baseUri, file));
                await vscode_1.workspace.fs.createDirectory(vscode_1.Uri.joinPath(fileUri, '..'));
                await vscode_1.workspace.fs.writeFile(fileUri, content);
            }
            await updateAiGeneratedWorkspacesFile(workspaceUri);
        });
        if (workspaceRoot && workspaceUri.fsPath.startsWith(workspaceRoot.fsPath + path.sep)) {
            // If the new workspace is a subfolder of the current workspace, do nothing
            return;
        }
        const message = vscode_1.l10n.t('Would you like to open the created workspace?');
        const open = vscode_1.l10n.t('Open');
        const openNewWindow = vscode_1.l10n.t('Open in New Window');
        const choices = [open, openNewWindow];
        const result = await vscode_1.window.showInformationMessage(message, { modal: true }, ...choices);
        if (result === open) {
            vscode_1.interactive.transferActiveChat(workspaceUri);
            logService.info('[newIntent] Opening folder: ' + workspaceUri.fsPath);
            vscode_1.commands.executeCommand('vscode.openFolder', workspaceUri);
        }
        else if (result === openNewWindow) {
            vscode_1.commands.executeCommand('vscode.openFolder', workspaceUri, true);
        }
    }
    catch (error) {
        const errorMessage = vscode_1.l10n.t('Failed to create workspace: {0}', projectName);
        logService.error(error, errorMessage);
        vscode_1.window.showErrorMessage(errorMessage);
        await vscode_1.workspace.fs.delete(workspaceUri, { recursive: true });
    }
}
async function getUniqueProjectName(projectFolder, projectName) {
    let i = 0;
    let uniqueProjectNameNotFound = true;
    let newProjectName = projectName.replace(/^\W+/, '');
    while (uniqueProjectNameNotFound) {
        try {
            await vscode_1.workspace.fs.stat(vscode_1.Uri.joinPath(projectFolder, newProjectName));
            newProjectName = projectName + '-' + ++i;
        }
        catch {
            uniqueProjectNameNotFound = false;
        }
    }
    return newProjectName;
}
async function checkFileExists(filePath) {
    try {
        await vscode_1.workspace.fs.stat(filePath);
        return true;
    }
    catch (error) {
        return false;
    }
}
async function updateAiGeneratedWorkspacesFile(workspaceUris) {
    const aiGeneratedFilePath = getAiGeneratedWorkspacesFile();
    if (!aiGeneratedFilePath) {
        return;
    }
    if ((await checkFileExists(aiGeneratedFilePath))) {
        const fileContnet = await vscode_1.workspace.fs.readFile(aiGeneratedFilePath).then(b => { return new TextDecoder().decode(b); });
        const workspaces = JSON.parse(fileContnet);
        workspaces.push(workspaceUris.toString());
        await vscode_1.workspace.fs.writeFile(aiGeneratedFilePath, Buffer.from(JSON.stringify(workspaces, null, 2)));
    }
    else {
        await vscode_1.workspace.fs.writeFile(aiGeneratedFilePath, Buffer.from(JSON.stringify([workspaceUris.toString()], null, 2)));
    }
}
function getAiGeneratedWorkspacesFile() {
    const vscodeFolderName = vscode_1.env.appName.indexOf('Insider') > 0 || vscode_1.env.appName.indexOf('Code - OSS Dev') >= 0 ? 'Code - Insiders' : 'Code';
    const homeDir = vscode_1.Uri.file(process.env.HOME || (process.env.USERPROFILE ? process.env.USERPROFILE : ''));
    switch (process.platform) {
        case 'darwin':
            return vscode_1.Uri.joinPath(homeDir, 'Library', 'Application Support', vscodeFolderName, 'User', 'workspaceStorage', 'aiGeneratedWorkspaces.json');
        case 'linux':
            return vscode_1.Uri.joinPath(homeDir, '.config', vscodeFolderName, 'User', 'workspaceStorage', 'aiGeneratedWorkspaces.json');
        case 'win32':
            return process.env.APPDATA
                ? vscode_1.Uri.joinPath(vscode_1.Uri.file(process.env.APPDATA), vscodeFolderName, 'User', 'workspaceStorage', 'aiGeneratedWorkspaces.json')
                : undefined;
        default:
            return;
    }
}
//# sourceMappingURL=newWorkspaceFollowup.js.map